#!/usr/bin/env python

#######################################################################
# -*- c-basic-offset: 8 -*-
# Copyright (c) 2015 Open Grid Computing, Inc. All rights reserved.
# Copyright (c) 2015 Sandia Corporation. All rights reserved.
# Under the terms of Contract DE-AC04-94AL85000, there is a non-exclusive
# license for use of this work by or on behalf of the U.S. Government.
# Export of this program may require a license from the United States
# Government.
#
# This software is available to you under a choice of one of two
# licenses.  You may choose to be licensed under the terms of the GNU
# General Public License (GPL) Version 2, available from the file
# COPYING in the main directory of this source tree, or the BSD-type
# license below:
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#      Redistributions of source code must retain the above copyright
#      notice, this list of conditions and the following disclaimer.
#
#      Redistributions in binary form must reproduce the above
#      copyright notice, this list of conditions and the following
#      disclaimer in the documentation and/or other materials provided
#      with the distribution.
#
#      Neither the name of Sandia nor the names of any contributors may
#      be used to endorse or promote products derived from this software
#      without specific prior written permission.
#
#      Neither the name of Open Grid Computing nor the names of any
#      contributors may be used to endorse or promote products derived
#      from this software without specific prior written permission.
#
#      Modified source versions must be plainly marked as such, and
#      must not be misrepresented as being the original software.
#
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#######################################################################

from __future__ import print_function
import struct
import cmd
import argparse
import sys
import os
import traceback
import json

from ldmsd import ldmsd_config, ldmsd_util, ldmsd_request
LDMSD_REQ_SOM_F=1
LDMSD_REQ_EOM_F=2
LDMSD_REQ_ALL_F=(LDMSD_REQ_SOM_F|LDMSD_REQ_EOM_F)
LDMSD_CLI_REQ=1
LDMSD_PRDCR_STATUS_REQ=0x104
LDMSD_PRDCR_SET_REQ=0x105
LDMSD_STRGP_STATUS_REQ=0x204
LDMSD_UPDTR_STATUS_REQ=0x304
LDMSD_PLUGN_STATUS_REQ=0x504

class LdmsdCmdParser(cmd.Cmd):
    def __init__(self, sockname = None, host_port = None, secretPath = None, infile=None):
        self.msg_no = 1
        if (sockname is None) and (host_port is None):
            raise ValueError("Expecting either sockname or host_port. None is given")

        if sockname is not None:
            self.ctrl = ldmsd_config.ldmsdUSocketConfig(ldmsd_sockpath = sockname)
            self.prompt = "{0}> ".format(os.path.basename(sockname))
            if secretPath is not None:
                print("Unix domain socket is in used. Ignore the path to the secret word")
        else:
            try:
                self.secretword = None
                if secretPath is not None:
                    try:
                        from ovis_lib import ovis_auth
                    except ImportError:
                        raise ImportError("No module named ovis_lib. Please "
                                        "make sure that ovis is built with "
                                        "--enable-swig")
                    self.secretword = ovis_auth.ovis_auth_get_secretword(secretPath, None)
            except:
                raise

            self.ctrl = ldmsd_config.ldmsdInetConfig(host = host_port['host'],
                                                     port = host_port['port'],
                                                     secretword = self.secretword)
            self.prompt = "{0}:{1}> ".format(host_port['host'], host_port['port'])

        if infile:
            cmd.Cmd.__init__(self, stdin=infile)
        else:
            cmd.Cmd.__init__(self)

    def __complete_attr_list(self, verb, text):
        req_opt_attr = self.ctrl.get_cmd_attr_list(verb)
        attr_list = []
        if req_opt_attr['req'] is not None:
            attr_list = req_opt_attr['req']
        if req_opt_attr['opt'] is not None:
            attr_list += req_opt_attr['opt']
        return ["{0}=".format(attr) for attr in attr_list if attr.startswith(text)]

    def emptyline(self):
        pass

    def __check_command_syntax(self, attr_value):
        tokens = attr_value.split(" ")
        for tk in tokens:
            if tk.endswith("="):
                return False
        return True

    def do_shell(self, args):
        """
        Execute a shell command
        """
        os.system(args)

    def do_say(self, args):
        """
        Print a message to the console
        """
        print(args)

    def precmd(self, line):
        if line[0:1] == '#':
            return ''
        return line

    def handle(self, verb, args):
        if not self.__check_command_syntax(args):
            print("Wrong syntax. There are attributes that no values are given.")
            return

        cmd_id = self.ctrl.get_cmd_id(verb)
        cmd = "{0}{1} {2}".format(cmd_id, verb, args)
        resp = self.ctrl.talk(cmd)
        resp = resp.rstrip()
        import re
        g = re.match(r"(-*)(\d+)", resp)
        if len(resp[g.end():]) > 0:
            print(resp[g.end():])

    def read_none_tty(self, fin):
        for cmd in fin:
            self.onecmd(cmd)

    def do_source(self, arg):
        """
        Parse commands from the specified file as if they were entered
        on the console.
        """
        script = open(arg, 'r')
        self.read_none_tty(script)
        for cmd in script:
            self.onecmd(cmd)
        script.close()

    def do_script(self, arg):
        exit_code, out, err = ldmsd_util.sh_exec(arg)
        if exit_code != 0:
            print("Script exited with code {0} and error: {1}".format(exit_code, err))
            return
        cfg = out.split("\n")
        for cmd in cfg:
            self.onecmd(cmd)

    def do_try(self, arg):
        print(self.__complete_attr_list(arg, ""))

    def do_usage(self, arg):
        """List the usage of the plugins loaded on the server.
        """
        self.handle('usage', arg)

    def complete_usage(self, text, line, begidx, endidx):
        return self.__complete_attr_list('usage', text)

    def do_load(self, arg):
        """
        Load a plugin at the Aggregator/Producer
        Parameters:
        name=     The plugin name
        """
        self.handle('load', arg)

    def complete_load(self, text, line, begidx, endidx):
        return self.__complete_attr_list('load', text)

    def do_prdcr_add(self, arg):
        """
        Add an LDMS Producer to the Aggregator
        Parameters:
        name=     A unique name for this Producer
        xprt=     The transport name [sock, rdma, ugni]
        host=     The hostname of the host
        port=     The port number on which the LDMS is listening
        type=     The connection type [active, passive]
        interval= The connection retry interval (us)
        """
        self.handle('prdcr_add', arg)

    def complete_prdcr_add(self, text, line, begidx, endidx):
        return self.__complete_attr_list('prdcr_add', text)

    def do_prdcr_del(self, arg):
        """
        Delete an LDMS Producer from the Aggregator. The producer
        cannot be in use or running.
        Parameters:
        name=    The Producer name
        """
        self.handle('prdcr_del', arg)

    def complete_prdcr_del(self, text, line, begidx, endidx):
        return self.__complete_attr_list('prdcr_del', text)

    def do_prdcr_start(self, arg):
        """
        Start the specified producer.
        Parameters:
        name=     The name of the producer
        [interval=] The connection retry interval in micro-seconds. If this is not
                  specified, the previously configured value will be used.
        """
        self.handle('prdcr_start', arg);

    def complete_prdcr_start(self, text, line, begidx, endidx):
        return self.__complete_attr_list('prdcr_start', text)

    def do_prdcr_start_regex(self, arg):
        """
        Start all producers matching a regular expression.
        Parameters:
        regex=     A regular expression
        [interval=]  The connection retry interval in micro-seconds. If this is not
                   specified, the previously configured value will be used.
        """
        self.handle('prdcr_start_regex', arg);

    def complete_prdcr_start_regex(self, text, line, begidx, endidx):
        return self.__complete_attr_list('prdcr_start_regex', text)

    def do_prdcr_stop(self, arg):
        """
        Stop the specified Producer.
        Parameters:
        name=  The producer name
        """
        self.handle('prdcr_stop', arg);

    def complete_prdcr_stop(self, text, line, begidx, endidx):
        return self.__complete_attr_list('prdcr_stop', text)

    def do_prdcr_stop_regex(self, arg):
        """
        Stop all producers matching a regular expression.
        Parameters:
        regex=   The regular expression
        """
        self.handle('prdcr_stop_regex', arg);

    def complete_prdcr_stop_regex(self, text, line, begidx, endidx):
        return self.__complete_attr_list('prdcr_stop_regex', text)

    def do_updtr_add(self, arg):
        """
        Add an updater process that will periodically sample
        Producer metric sets
        Parameters:
        name=     The update policy name
        interval= The update/collect interval
        [offset=]   Offset for synchronized aggregation
        """
        self.handle('updtr_add', arg)

    def complete_updtr_add(self, text, line, begidx, endidx):
        return self.__complete_attr_list('updtr_add', text)

    def do_updtr_del(self, arg):
        """
        Remove an updater from the configuration
        Parameter:
        name=     The update policy name
        """
        self.handle('updtr_del', arg)

    def complete_updtr_del(self, text, line, begidx, endidx):
        return self.__complete_attr_list('updtr_del', text)

    def do_updtr_match_add(self, arg):
        """
        Add a match condition that specifies the sets to update.
        Parameters::
        name=   The update policy name
        regex=  The regular expression string
        match=  The value with which to compare; if match=inst,
                the expression will match the set's instance name, if
                match=schema, the expression will match the set's
                schema name.
        """
        self.handle('updtr_match_add', arg)

    def complete_updtr_match_add(self, text, line, begidx, endidx):
        return self.__complete_attr_list('updtr_match_add', text)

    def do_updtr_match_del(self, arg):
        """
        Remove a match condition from the Updater. The
        parameters are as follows:
        name=   The update policy name
        regex=  The regular expression string
        match=  The value with which to compare; if match=inst,
                the expression will match the set's instance name, if
                match=schema, the expression will match the set's
                schema name.
        """
        self.handle('updtr_match_del', arg)

    def complete_updtr_match_del(self, text, line, begidx, endidx):
        return self.__complete_attr_list('updtr_match_del', text)

    def do_updtr_prdcr_add(self, arg):
        """
        Add matching Producers to an Updater policy. The parameters are as
        follows:
        name=   The update policy name
        regex=  A regular expression matching zero or more producers
        """
        self.handle('updtr_prdcr_add', arg)

    def complete_updtr_prdcr_add(self, text, line, begidx, endidx):
        return self.__complete_attr_list('updtr_prdcr_add', text)

    def do_updtr_prdcr_del(self, arg):
        """
        Remove matching Producers from an Updater policy. The parameters are as
        follows:
        name=    The update policy name
        regex=   A regular expression matching zero or more producers
        """
        self.handle('updtr_prdcr_del', arg)

    def complete_updtr_prdcr_del(self, text, line, begidx, endidx):
        return self.__complete_attr_list('updtr_prdcr_del', text)

    def do_updtr_start(self, arg):
        """
        Start updaters. The parameters to the commands are as
        follows:
        name=     The update policy name
        [interval=] The update interval in micro-seconds. If this is not
                  specified, the previously configured value will be used.
        [offset=]   Offset for synchronization
        """
        self.handle('updtr_start', arg);

    def complete_updtr_start(self, text, line, begidx, endidx):
        return self.__complete_attr_list('updtr_start', text)

    def do_updtr_stop(self, arg):
        """
        Stop the Updater. The Updater must be stopped in order to
        change it's configuration.
        Paramaeters:
        name=   The update policy name
        """
        self.handle('updtr_stop', arg);

    def complete_updtr_stop(self, text, line, begidx, endidx):
        return self.__complete_attr_list('updtr_stop', text)

    def do_strgp_add(self, arg):
        """
        Create a Storage Policy and open/create the storage instance.
        Parameters:
        name=      The unique storage policy name.
        plugin=    The name of the storage backend.
        container= The storage backend container name.
        schema=    The schema name of the metric set to store.
        """
        self.handle('strgp_add', arg)

    def complete_strgp_add(self, text, line, begidx, endidx):
        return self.__complete_attr_list('strgp_add', text)

    def do_strgp_del(self, arg):
        """
        Remove a Storage Policy. All updaters must be stopped in order for
        a storage policy to be deleted.
        Parameters:
        name=   The storage policy name
        """
        self.handle('strgp_del', arg)

    def complete_strgp_del(self, text, line, begidx, endidx):
        return self.__complete_attr_list('strgp_del', text)

    def do_strgp_prdcr_add(self, arg):
        """
        Add a regular expression used to identify the producers this
        storage policy will apply to.
        Parameters:
        name=   The storage policy name
        regex=  A regular expression matching metric set producers
        """
        self.handle('strgp_prdcr_add', arg)

    def complete_strgp_prdcr_add(self, text, line, begidx, endidx):
        return self.__complete_attr_list('strgp_prdcr_add', text)

    def do_strgp_prdcr_del(self, arg):
        """
        Remove a regular expression from the producer match list.
        Parameters:
        name=   The storage policy name
        regex=  The regular expression to remove
        """
        self.handle('strgp_prdcr_del', arg)

    def complete_strgp_prdcr_del(self, text, line, begidx, endidx):
        return self.__complete_attr_list('strgp_prdcr_del', text)

    def do_strgp_metric_add(self, arg):
        """
        Add the name of a metric to store. If the metric list is NULL,
        all metrics in the metric set will be stored.
        Parameters:
        name=   The storage policy name
        metric= The metric name
        """
        self.handle('strgp_metric_add', arg)

    def complete_strgp_metric_add(self, text, line, begidx, endidx):
        return self.__complete_attr_list('strgp_metric_add', text)

    def do_strgp_metric_del(self, arg):
        """
        Remove a metric from the set of stored metrics.
        Parameters:
        name=   The storage policy name
        metric= The metric to remove
        """
        self.handle('strgp_metric_del', arg)

    def complete_strgp_set_del(self, text, line, begidx, endidx):
        return self.__complete_attr_list('strgp_metric_del', text)

    def do_strgp_start(self, arg):
        """
        Start storage policy.
        name=    The storage policy name
        """
        self.handle('strgp_start', arg);

    def complete_strgp_start(self, text, line, begidx, endidx):
        return self.__complete_attr_list('strgp_start', text)

    def do_strgp_stop(self, arg):
        """
        Stop storage policies. A storage policy must be stopped in order to
        change its configuration.
        Paramaeters:
        name=    The storage policy name
        """
        self.handle('strgp_stop', arg);

    def complete_strgp_stop(self, text, line, begidx, endidx):
        return self.__complete_attr_list('strgp_stop', text)

    #
    # Backward compatibility commands
    #
    def do_info(self, arg):
        """
        Tell the daemon to dump it's internal state to the log file.
        Parameters:
        [name=]   Reports only the specified objects. The choices are
                  prdcr, updtr and strgp.
                     'prdcr': list the state of all producers.
                     'updtr': list the state of all update policies.
                     'strgp': list the state of all storage policies.
        """
        self.handle('info', arg)

    def complete_info(self, text, line, begidx, endidx):
        return self.__complete_attr_list('info', text)

    def format_request(self, cmd):
        self.msg_no = self.msg_no + 1
        return struct.pack('iiiii', -1, LDMSD_REQ_ALL_F, self.msg_no, cmd, 20)

    def do_prdcr_status(self, arg):
        msg = self.format_request(LDMSD_PRDCR_STATUS_REQ)
        rc = self.ctrl.socket.sendall(bytes(msg))
        response = ""
        while True:
            hdr = self.ctrl.socket.recv(20)
            (marker, flags, msg_no, cmd_id, rec_len) = struct.unpack('iiiii', hdr)
            data = self.ctrl.socket.recv(rec_len - 20)
            response += data
            if flags:
                break
        producers =  json.loads(response)
        print("Name             Host             Port         Transport    State")
        print("---------------- ---------------- ------------ ------------ ------------")
        for prdcr in producers:
            print("{0:16} {1:16} {2:12} {3:12} {4:12}".format(prdcr['name'],
                                                              prdcr['host'],
                                                              prdcr['port'],
                                                              prdcr['transport'],
                                                              prdcr['state']))
            for pset in prdcr['sets']:
                print("    {0:16} {1:16} {2}".format(pset['inst_name'],
                                                     pset['schema_name'],
                                                     pset['state']))
    def do_prdcr_set(self, arg):
        try:
            attr1 = ldmsd_request.LDMSD_Req_Attr(1, arg)
            req = ldmsd_request.LDMSD_Request(LDMSD_PRDCR_SET_REQ, attrs = [attr1,])
            req.send(self.ctrl.socket)
            metric_sets = req.receive(self.ctrl.socket)
            #while True:
            #    hdr = self.ctrl.socket.recv(20)
            #    (marker, flags, msg_no, cmd_id, rec_len) = struct.unpack('iiiii', hdr)
            #    data = self.ctrl.socket.recv(rec_len - 20)
            #    response += data
            #    if flags:
            #        break
            metric_sets = json.loads(metric_sets)
            print("Name             Schema Name      State")
            print("---------------- ---------------- ------------ ")
            for pset in metric_sets:
                print("    {0:16} {1:16} {2}".format(pset['inst_name'],
                                                     pset['schema_name'],
                                                     pset['state']))
        except Exception as e:
            print(repr(e))

    def do_updtr_status(self, arg):
        msg = self.format_request(LDMSD_UPDTR_STATUS_REQ)
        rc = self.ctrl.socket.sendall(bytes(msg))
        response = ""
        while True:
            hdr = self.ctrl.socket.recv(20)
            (marker, flags, msg_no, cmd_id, rec_len) = struct.unpack('iiiii', hdr)
            data = self.ctrl.socket.recv(rec_len - 20)
            response += data
            if flags:
                break
        updaters = json.loads(response)
        print("Name             Interval     Offset       State")
        print("---------------- ------------ ------------ ------------")
        for updtr in updaters:
            print("{0:16} {1:12} {2:12} {3}".format(
                updtr['name'], updtr['interval'], updtr['offset'], updtr['state']))
            for prdcr in updtr['producers']:
                print("    {0:16} {1:16} {2:12} {3:12} {4:12}".format(
                    prdcr['name'], prdcr['host'], prdcr['port'],
                    prdcr['transport'], prdcr['state']))

    def do_strgp_status(self, arg):
        msg = self.format_request(LDMSD_STRGP_STATUS_REQ)
        rc = self.ctrl.socket.sendall(bytes(msg))
        response = ""
        while True:
            hdr = self.ctrl.socket.recv(20)
            (marker, flags, msg_no, cmd_id, rec_len) = struct.unpack('iiiii', hdr)
            data = self.ctrl.socket.recv(rec_len - 20)
            response += data
            if flags:
                break
        policies = json.loads(response)
        print("Name             Container        Schema           Plugin           State")
        print("---------------- ---------------- ---------------- ---------------- ------------")
        for strgp in policies:
            print("{0:16} {1:16} {2:16} {3:16} {4}".format(
                strgp['name'], strgp['container'], strgp['schema'],
                strgp['plugin'], strgp['state']))
            print("    producers: ", end='')
            for prdcr in strgp['producers']:
                print("{0} ".format(prdcr), end='')
            print('')
            print("    metrics: ", end='')
            for metric in strgp['metrics']:
                print("{0} ".format(metric), end='')
            print('')

    def do_plugn_status(self, arg):
        msg = self.format_request(LDMSD_PLUGN_STATUS_REQ)
        rc = self.ctrl.socket.sendall(bytes(msg))
        response = ""
        while True:
            hdr = self.ctrl.socket.recv(20)
            (marker, flags, msg_no, cmd_id, rec_len) = struct.unpack('iiiii', hdr)
            data = self.ctrl.socket.recv(rec_len - 20)
            response += data
            if flags:
                break
        plugins = json.loads(response)
        print("Name         Type         Interval     Offset       Libpath")
        print("------------ ------------ ------------ ------------ ------------")
        for plugn in plugins:
            print("{0:12} {1:12} {2:12} {3:12} {4:12}".format(
                plugn['name'], plugn['type'],
                plugn['sample_interval_us'], plugn['sample_offset_us'],
                plugn['libpath']))

    def do_status(self, arg):
        all__ = (len(arg) == 0)
        if "prdcr" in arg or all__:
            self.do_prdcr_status(arg)
        if "updtr" in arg or all__:
            self.do_updtr_status(arg)
        if "strgp" in arg or all__:
            self.do_strgp_status(arg)

    def do_term(self, arg):
        """
        Unload the plugin
        Parameters:
        name=   The plugin name
        """
        self.handle('term', arg)

    def complete_term(self, text, line, begidx, endidx):
        return self.__complete_attr_list('term', text)

    def do_config(self, arg):
        """
        Send a configuration command to the specified plugin.
        Parameters:
        name=   The plugin name
        ...     Plugin specific attr=value tuples
        """
        self.handle('config', arg)

    def complete_config(self, text, line, begidx, endidx):
        return self.__complete_attr_list('config', text)

    def do_start(self, arg):
        """
        Start a sampler plugin
        Parameters:
        name=     The plugin name
        interval= The sample interval in microseconds
        [offset=] Optional offset (shift) from the sample mark in microseconds.
                  Offset can be positive or negative with magnitude up to 1/2
                  the sample interval. If this offset is specified, including 0,
                  collection will be synchronous; if the offset is not specified,
                  collection will be asynchronous.
        """
        self.handle('start', arg)

    def complete_start(self, text, line, begidx, endidx):
        return self.__complete_attr_list('start', text)

    def do_stop(self, arg):
        """
        Stop a sampler plugin
        Parameters:
        name=     The plugin name
        """
        self.handle('stop', arg)

    def complete_stop(self, text, line, begidx, endidx):
        return self.__complete_attr_list('stop', text)

    def do_add(self, arg):
        """
        Adds a host to the list of hosts monitored by this ldmsd.
        Parameters:
        host=       The hostname. This can be an IP address or DNS hostname.
        type=       One of the following host types:
            active   An connection is initiated with the peer and
                     it's metric sets will be periodically queried.
            passive  A connect request is expected from the specified host.
                     After this request is received, the peer's metric sets
                     will be queried periodically.
            bridging A connect request is initiated to the remote peer,
                     but it's metric sets are not queried. This is the active
                     side of the passive host above.
            local    The to-be-added host is the local host. The given
                     set name(s) must be the name(s) of local set(s).
                     This option is used so that ldmsd can store
                     the given local set(s) if it is configured to do so.
        [xprt=]     The transport type, defaults to 'sock'
           sock      The sockets transport.
           rdma      The OFA Verbs Transport for Infiniband or iWARP.
           ugni      The Cray Gemini transport.
        [port=]     The port number to connect on, defaults to 50000.
        sets=       The list of metric set names to be queried.
                    The list is comma separated. If the type is bridging,
                    no set names should be specified.
        [interval=] An optional sampling interval in microseconds,
                    defaults to 1000000.
        [offset=]   An optional offset (shift) from the sample mark
                    in microseconds. If this offset is specified,
                    including 0, the collection will be synchronous;
                    if the offset is not specified, the collection
                    will be asychronous
        [agg_no=]   The number of the aggregator that this is standby for.
                    Defaults to 0 which means this is an active aggregator.
        """
        return self.handle('add', arg)

    def complete_add(self, text, line, begidx, endidx):
        return self.__complete_attr_list('add', text)

    def do_store(self, arg):
        """
        Saves a metrics from one or more hosts to persistent storage.
        Parameters:
        policy=      The storage policy name. This must be unique.
        container=   The container name used by the plugin to name data.
        schema=      A name used to name the set of metrics stored together.
        [metrics=]   A comma separated list of metric names. If not specified,
                     all metrics in the metric set will be saved.
        [hosts=]     The set of hosts whose data will be stored. If hosts is not
                     specified, the metric set will be saved for all hosts. If
                     specified, the value should be a comma separated list of
                     host names.
        """
        return self.handle('store', arg)

    def complete_store(self, text, line, begidx, endidx):
        return self.__complete_attr_list('store', text)

    def do_udata(self, arg):
        """
        Set the user data value for a metric in a metric set. This is typically used to
        convey the Component Id to the Aggregator.
        Parameters:
        set=   The sampler plugin name
        metric= The metric name
        udata=  The desired user-data. This is a 64b unsigned integer.
        """
        self.handle('udata', arg)

    def complete_udata(self, text, line, begidx, endidx):
        return self.__complete_attr_list('udata', text)

    def do_udata_regex(self, arg):
        """
        Set the user data of multiple metrics using regular expression.
        The user data of the first matched metric is set to the base value.
        The base value is incremented by the given 'incr' value and then
        sets to the user data of the consecutive matched metric and so on.
        Parameters:
             set=           The metric set name
             regex=         A regular expression to match metric names to be set
             base=          The base value of user data (uint64)
             [incr=]        Increment value (int). The default is 0. If incr is 0,
                            the user data of all matched metrics are set
                            to the base value.
        """
        self.handle('udata_regex', arg)

    def complete_udata_regex(self, text, line, begidx, endidx):
        return self.__complete_attr_list('udata_regex', text)

    def do_standby(self, arg):
        """
        ldmsd will update the standby state (standby/active) of
        the given aggregator number
        Parameters:
        agg_no=    Unique integer id for an aggregator from 1 to 64
        state=     0/1 - standby/active
        """
        self.handle('standby', arg)

    def complete_standby(self, text, line, begidx, endidx):
        return self.__complete_attr_list('standby', text)

    def do_loglevel(self, arg):
        """
        Changing the verbosity level of ldmsd
        Parameters:
        level=    Verbosity levels [DEBUG, INFO, ERROR, CRITICAL, QUIET]
        """
        self.handle('loglevel', arg)

    def complete_loglevel(self, text, line, begidx, endidx):
        return self.__complete_attr_list('loglevel', text)

    def do_logrotate(self, arg):
        """
        Close the current log file, rename it by appending
	the timestamp in seconds, and then open a new file
	with the name given at the ldmsd command-line.
        """
        self.handle('logrotate', arg)

    def complete_logrotate(self, text, line, begidx, endidx):
        return self.__complete_attr_list('logrotate', text)

    def do_version(self, arg):
        """
        Get the LDMS version the running LDMSD bases on.
        """
        self.handle('version', arg)

    def do_include(self, arg):
        """
        Include a configuration file
        """
        self.handle('include', arg)

    def do_env(self, arg):
        """
        Set ldmsd environment
        """
        self.handle('env', arg)

    def do_EOF(self, arg):
        """
        Ctrl-D will exit the shell
        """
        return True

    def do_quit(self, arg):
        """
        Quit the LDMSD shell
        """
        self.ctrl.close()
        return True

if __name__ == "__main__":
    is_debug = True
    try:
        parser = argparse.ArgumentParser(description="Configure an LDMS Daemon. " \
                                         "To connect to an ldmsd, either give " \
                                         "the socket path of the ldmsd or " \
                                         "give both hostname and inet control port. " \
                                         "If all are given, the sockname takes the priority.")
        parser.add_argument("--sockname",
                            help="Specify the UNIX socket used to communicate with LDMSD.")
        parser.add_argument('--host',
                            help = "Hostname of ldmsd to connect to")
        parser.add_argument('--port',
                            help = "Inet ctrl listener port of ldmsd")
        parser.add_argument('--auth_file',
                            help = "Path to the file containing the secretword")
        parser.add_argument('--source',
                            help = "Path to the config file")
        parser.add_argument('--script',
                            help = "Execute the script and send the output \
                            commands to the connected ldmsd")
        parser.add_argument('--debug', action = "store_true",
                            help = argparse.SUPPRESS)

        args = parser.parse_args()

        is_debug = args.debug

        if (args.sockname is None) and (args.host is None or args.port is None):
            print("Please give either --sockname or both of --host and --port.")
            sys.exit(1)

        if args.sockname is not None:
            cmdParser = LdmsdCmdParser(sockname = args.sockname)
        else:
            cmdParser = LdmsdCmdParser(host_port = {'host': args.host,
                                                    'port': int(args.port)},
                                       secretPath = args.auth_file)

        if args.source is not None or args.script is not None:
            if args.source is not None:
                cmdParser.do_source(args.source)
            if args.script is not None:
                cmdParser.do_script(args.script)
            cmdParser.do_quit(None)
        else:
            if sys.stdin.isatty() is False:
                cmdParser.read_none_tty(sys.stdin)
                cmdParser.do_quit(None)
            else:
                cmdParser.cmdloop("Welcome to the LDMSD control processor")
    except KeyboardInterrupt:
        sys.exit(0)
    except Exception as e:
        if is_debug:
            print(is_debug)
            traceback.print_exc()
            sys.exit(2)
        else:
            print(e)
