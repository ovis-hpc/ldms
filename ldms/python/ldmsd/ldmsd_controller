#!/usr/bin/env python3

#######################################################################
# -*- c-basic-offset: 8 -*-
# Copyright (c) 2015-2019 National Technology & Engineering Solutions
# of Sandia, LLC (NTESS). Under the terms of Contract DE-NA0003525 with
# NTESS, the U.S. Government retains certain rights in this software.
# Copyright (c) 2015-2019 Open Grid Computing, Inc. All rights reserved.
#
# This software is available to you under a choice of one of two
# licenses.  You may choose to be licensed under the terms of the GNU
# General Public License (GPL) Version 2, available from the file
# COPYING in the main directory of this source tree, or the BSD-type
# license below:
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#      Redistributions of source code must retain the above copyright
#      notice, this list of conditions and the following disclaimer.
#
#      Redistributions in binary form must reproduce the above
#      copyright notice, this list of conditions and the following
#      disclaimer in the documentation and/or other materials provided
#      with the distribution.
#
#      Neither the name of Sandia nor the names of any contributors may
#      be used to endorse or promote products derived from this software
#      without specific prior written permission.
#
#      Neither the name of Open Grid Computing nor the names of any
#      contributors may be used to endorse or promote products derived
#      from this software without specific prior written permission.
#
#      Modified source versions must be plainly marked as such, and
#      must not be misrepresented as being the original software.
#
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#######################################################################

from __future__ import print_function
from builtins import str
import struct
import cmd
import argparse
import sys
import os
import traceback
import json
import re

from ldmsd import ldmsd_config, ldmsd_util, ldmsd_request
from ldmsd.ldmsd_request import LDMSD_Request, LDMSD_Req_Attr
from ldmsd.ldmsd_request import LDMSD_Req_Attr
import errno

LDMSD_REQ_SOM_F=1
LDMSD_REQ_EOM_F=2
LDMSD_REQ_ALL_F=(LDMSD_REQ_SOM_F|LDMSD_REQ_EOM_F)
LDMSD_CLI_REQ=1
LDMSD_PRDCR_STATUS_REQ=0x104
LDMSD_PRDCR_SET_REQ=0x107
LDMSD_STRGP_STATUS_REQ=0x204
LDMSD_UPDTR_STATUS_REQ=0x304
LDMSD_PLUGN_STATUS_REQ=0x504

def cvt_intrvl_off_to_str(interval_us, offset_us):
    interval_s = float(interval_us) / 1000000.0
    offset_ms = float(offset_us) / 1000.0
    return str(interval_s) + "s:" + str(offset_ms) + "ms"

class LdmsdCmdParser(cmd.Cmd):
    def __init__(self, host = None, port = None, xprt = None, infile=None,
                 auth=None, auth_opt=None):
        self.msg_no = 1

        if host and port:
            self.ctrl = ldmsd_config.ldmsdInbandConfig(host = host,
                                                   port = port,
                                                   xprt = xprt,
                                                   auth = auth,
                                                   auth_opt = auth_opt)
            self.prompt = "{0}:{1}:{2}> ".format(xprt, host, port)
        else:
            self.ctrl = None
            self.prompt = "(not connected)> "

        if infile:
            cmd.Cmd.__init__(self, stdin=infile)
        else:
            cmd.Cmd.__init__(self)

    def __complete_attr_list(self, verb, text):
        req_opt_attr = self.ctrl.get_cmd_attr_list(verb)
        attr_list = []
        if req_opt_attr['req'] is not None:
            attr_list = req_opt_attr['req']
        if req_opt_attr['opt'] is not None:
            attr_list += req_opt_attr['opt']
        return ["{0}=".format(attr) for attr in attr_list if attr.startswith(text)]

    def emptyline(self):
        pass

    def __check_command_syntax(self, attr_value):
        tokens = attr_value.split(" ")
        for tk in tokens:
            if tk.endswith("="):
                return False
        return True

    def do_shell(self, args):
        """
        Execute a shell command
        """
        os.system(args)

    def do_comment(self, args):
        """
        skip comments
        """
        pass

    def do_say(self, args):
        """
        Print a message to the console
        """
        print(args)

    def do_connect(self, args):
        """
        Connect to an LDMS daemon
        Parameters:
        xprt=     The transport name [sock, rdma, ugni] (default: sock)
        host=     The hostname of the host (default: localhost)
        port=     The port number on which the LDMS is listening
        auth=     The authentication method (default: none)

        Other ATTR=VALUE parameters will be passed to authentication plugin.
        """
        if self.ctrl:
            print("WARN: Already connected, do nothing.")
            return None
        kwargs = {
                "xprt": "sock",
                "host": "localhost",
                "port": None,
                "auth": "none",
                "auth_opt": {},
            }
        r = re.compile(r"\s*(\w+)=(\w+)")
        for attr, value in r.findall(args):
            if attr in kwargs:
                kwargs[attr] = value
            else:
                # treat as auth options
                kwargs["auth_opt"][attr] = value
        self.ctrl = ldmsd_config.ldmsdInbandConfig(**kwargs)
        self.prompt = "{0}:{1}:{2}> ".format(kwargs["xprt"],
                                             kwargs["host"],
                                             kwargs["port"])

    def complete_connect(self, text, line, begidx, endidx):
        name_list = ["xprt=", "host=", "port=", "auth="]
        full_list = ["xprt=(sock|rdma|ugni)",
                     "host=HOSTNAME",
                     "port=PORT",
                     "auth=AUTH_METHOD"]
        if not text:
            return full_list
        return [x for x in name_list if x.startswith(text)]

    def precmd(self, line):
        if line[0:1] == '#':
            return ''
        return line

    def handle(self, verb, args):
        if args and not self.__check_command_syntax(args):
            print("Syntax error, there are attributes for which no value is given.")

        if not self.ctrl:
            print("Error: no LDMS connection")
            return None

        attr_list = []
        if args:
            attr_s = []
            attr_str_list = args.split()

            for attr_str in attr_str_list:
                name = None
                value = None
                try:
                    [name, value] = attr_str.split("=")
                except ValueError:
                    # keyword
                    [name] = attr_str.split("=")
                except:
                    raise
                if (verb == "config" and name != "name") or (verb == "env"):
                    attr_s.append(attr_str)
                elif (verb == "auth_add" and name not in ["name", "plugin"]):
                    attr_s.append(attr_str)
                else:
                    try:
                        attr = LDMSD_Req_Attr(value = value, attr_name = name)
                    except KeyError:
                        attr_s.append(attr_str)
                    except Exception:
                        raise
                    else:
                        attr_list.append(attr)

            if len(attr_s) > 0:
                attr_str = " ".join(attr_s)
                attr = LDMSD_Req_Attr(value = attr_str, attr_id = LDMSD_Req_Attr.STRING)
                attr_list.append(attr)

        try:
            request = LDMSD_Request(command = verb, attrs = attr_list)
        except KeyError:
            print("'{0}' is not supported.".format(verb))
            return None
        except:
            raise

        try:
            request.send(self.ctrl)
            if is_debug:
                print("Sent request {0}".format(request.message_number_get()))
        except:
            print("Failed to send the command. The connection might be disconnected.")
            print("Please 'quit' the interative session")
            return {'msg': "", 'errcode': errno.EINTR}

        resp = request.receive(self.ctrl)
        if is_debug:
            print("Received the response of request {0}".format(request.message_number_get()))
            print(resp)
        if 'errcode' in resp.keys() and resp['errcode'] != 0:
                print(resp['msg'])
        return resp

    def read_none_tty(self, fin):
        for cmd in fin:
            self.onecmd(cmd)

    def do_source(self, arg):
        """
        Parse commands from the specified file as if they were entered
        on the console.
        """
        script = open(arg, 'r')
        self.read_none_tty(script)
        for cmd in script:
            self.onecmd(cmd)
        script.close()

    def do_script(self, arg):
        """
        Execute the given executable file and submit the resulting configuration to LDMSD
        Example:
            script /path/to/executable
        """
        exit_code, out, err = ldmsd_util.sh_exec(arg)
        if exit_code != 0:
            print("Script exited with code {0} and error: {1}".format(exit_code, err))
            return
        cfg = out.split("\n")
        for cmd in cfg:
            self.onecmd(cmd)

    def do_try(self, arg):
        print(self.__complete_attr_list(arg, ""))

    def do_usage(self, arg):
        """List the usage of the plugins loaded on the server.
        """
        resp = self.handle('usage', arg)
        if resp['errcode'] == 0:
            print(resp['msg'])

    def complete_usage(self, text, line, begidx, endidx):
        return self.__complete_attr_list('usage', text)

    def do_load(self, arg):
        """
        Load a plugin at the Aggregator/Producer
        Parameters:
        name=     The plugin name
        """
        self.handle('load', arg)

    def complete_load(self, text, line, begidx, endidx):
        return self.__complete_attr_list('load', text)

    def do_daemon_exit(self, arg):
        """
        Exit the connected LDMS daemon
        """
        resp = self.handle('daemon_exit', arg)
        if resp['errcode'] == 0:
            self.do_quit(arg)
            print("Please 'quit' the ldmsd_controller interface")

    def complete_daemon_exit(self, text, line, begidx, endidx):
        return self.__complete_attr_list('daemon_exit', text)

    def do_prdcr_add(self, arg):
        """
        Add an LDMS Producer to the Aggregator
        Parameters:
        name=     A unique name for this Producer
        xprt=     The transport name [sock, rdma, ugni]
        host=     The hostname of the host
        port=     The port number on which the LDMS is listening
        type=     The connection type [active, passive]
        interval= The connection retry interval (us)
        auth=     The authentication method
        [perm=]   The permission to modify the producer in the future.
        """
        self.handle('prdcr_add', arg)

    def complete_prdcr_add(self, text, line, begidx, endidx):
        return self.__complete_attr_list('prdcr_add', text)

    def do_prdcr_del(self, arg):
        """
        Delete an LDMS Producer from the Aggregator. The producer
        cannot be in use or running.
        Parameters:
        name=    The Producer name
        """
        self.handle('prdcr_del', arg)

    def complete_prdcr_del(self, text, line, begidx, endidx):
        return self.__complete_attr_list('prdcr_del', text)

    def do_prdcr_start(self, arg):
        """
        Start the specified producer.
        Parameters:
        name=     The name of the producer
        [interval=] The connection retry interval in micro-seconds. If this is not
                  specified, the previously configured value will be used.
        """
        self.handle('prdcr_start', arg)

    def complete_prdcr_start(self, text, line, begidx, endidx):
        return self.__complete_attr_list('prdcr_start', text)

    def do_prdcr_start_regex(self, arg):
        """
        Start all producers matching a regular expression.
        Parameters:
        regex=     A regular expression
        [interval=]  The connection retry interval in micro-seconds. If this is not
                   specified, the previously configured value will be used.
        """
        self.handle('prdcr_start_regex', arg)

    def complete_prdcr_start_regex(self, text, line, begidx, endidx):
        return self.__complete_attr_list('prdcr_start_regex', text)

    def do_prdcr_stop(self, arg):
        """
        Stop the specified Producer.
        Parameters:
        name=  The producer name
        """
        self.handle('prdcr_stop', arg)

    def complete_prdcr_stop(self, text, line, begidx, endidx):
        return self.__complete_attr_list('prdcr_stop', text)

    def do_prdcr_stop_regex(self, arg):
        """
        Stop all producers matching a regular expression.
        Parameters:
        regex=   The regular expression
        """
        self.handle('prdcr_stop_regex', arg)

    def complete_prdcr_stop_regex(self, text, line, begidx, endidx):
        return self.__complete_attr_list('prdcr_stop_regex', text)

    def do_prdcr_subscribe(self, arg):
        """
        Subscribe for stream data from all matching producers
        Parameters:
        regex=     A regular expression matching producer names
        stream=    The stream name
        """
        self.handle('prdcr_subscribe', arg)

    def complete_prdcr_subscribe(self, text, line, begidx, endidx):
        return self.__complete_attr_list('prdcr_subscribe', text)

    def do_prdcr_unsubscribe(self, arg):
        """
        Subscribe for stream data from all matching producers
        Parameters:
        regex=     A regular expression matching producer names
        stream=    The stream name
        """
        self.handle('prdcr_unsubscribe', arg)

    def complete_prdcr_unsubscribe(self, text, line, begidx, endidx):
        return self.__complete_attr_list('prdcr_unsubscribe', text)

    def do_prdcr_stream_dir(self, arg):
        """
        Get stream_dir of the matched prdcr. The connected LDMSD acts as a proxy.
        Parameters:
        regex=     A regular expression matching producer names
        """
        FIRST = "first_ts"
        LAST = "last_ts"
        RATE = "bytes/sec"
        FREQ = "msg/sec"

        def dur(info):
            return (info[LAST] - info[FIRST])/60.0

        def rate(info):
            if not info or RATE not in info.keys():
                return "-"
            return info[RATE]

        def freq(info):
            if not info or FREQ not in info.keys():
                return "-"
            return info[FREQ]

        def total_bytes(info):
            if not info or "total_bytes" not in info.keys():
                return "-"
            return info['total_bytes']

        def count(info):
            if not info or "count" not in info.keys():
                return "-"
            return info['count']

        resp = self.handle('prdcr_stream_dir', arg)
        if resp is None:
            raise RuntimeError("no response")
        if (resp['errcode'] == 0):
            streams = json.loads(resp['msg'])
            print("Name         Producer     mode            bytes/sec    msg/sec      total bytes  msg count   ")
            print("-" * 12, "-" * 12, "-" * 15, "-" * 12, "-" * 12, "-" * 12, "-" * 12)
            # print("--------------- -------------- --------------- ----- ----------------- -----------\n")
            for sname,s in streams.items():
                print(f"{sname:12}")
                for name,p in s.items():
                    if sname == "_AGGREGATED_":
                        p['mode'] = ""
                    print(f"             {name:12} {p['mode']:15} {rate(p['info']):>12} {freq(p['info']):>12} {total_bytes(p['info']):>12} {count(p['info']):>12}")

    def complete_prdcr_stream_dir(self, text, line, begidx, endidx):
        return self.__complete_attr_list('prdcr_stream_dir', text)

    def do_updtr_add(self, arg):
        """
        Add an Updater that will periodically update Producer metric sets either
        by pulling the content or by registering for an update push. The default
        is to pull set contents.
        Parameters:
        name=       The update policy name
        [interval=] The update/collect interval. This is required only when the
                    push argument is not given.
        [offset=]   Offset for synchronized aggregation
        [push=]     [onchange|true] 'onchange' means the
                    Updater will get an update whenever the set source ends a
                    transaction or pushes the update. 'true' means the Updater
                    will receive an update only when the set source explicitly
                    pushes the update.
                    If `push` is used, `auto_interval` cannot be `true`.
        [auto_interval=]   [true|false] If true, the updater will schedule
                           set updates according to the update hint. The sets
                           with no hints will not be updated. If false, the
                           updater will schedule the set updates according to
                           the given interval and offset values. If not
                           specified, the value is `false`.
        [perm=]     The permission to modify the updater in the future.
        """
        self.handle('updtr_add', arg)

    def complete_updtr_add(self, text, line, begidx, endidx):
        return self.__complete_attr_list('updtr_add', text)

    def do_updtr_del(self, arg):
        """
        Remove an updater from the configuration
        Parameter:
        name=     The update policy name
        """
        self.handle('updtr_del', arg)

    def complete_updtr_del(self, text, line, begidx, endidx):
        return self.__complete_attr_list('updtr_del', text)

    def do_updtr_match_add(self, arg):
        """
        Add a match condition that specifies the sets to update.
        Parameters::
        name=   The update policy name
        regex=  The regular expression string
        match=  The value with which to compare; if match=inst,
                the expression will match the set's instance name, if
                match=schema, the expression will match the set's
                schema name.
        """
        self.handle('updtr_match_add', arg)

    def complete_updtr_match_add(self, text, line, begidx, endidx):
        return self.__complete_attr_list('updtr_match_add', text)

    def do_updtr_match_del(self, arg):
        """
        Remove a match condition from the Updater. The
        parameters are as follows:
        name=   The update policy name
        regex=  The regular expression string
        match=  The value with which to compare; if match=inst,
                the expression will match the set's instance name, if
                match=schema, the expression will match the set's
                schema name.
        """
        self.handle('updtr_match_del', arg)

    def complete_updtr_match_del(self, text, line, begidx, endidx):
        return self.__complete_attr_list('updtr_match_del', text)

    def do_updtr_match_list(self, arg):
        """
        Return sets matched to this updater with updtr_match_add.
        Parameters are as follows:
        name=  The update policy name. If none, return all updaters
        """
        resp = self.handle('updtr_match_list', arg)
        if resp['errcode'] == 0:
            updaters = json.loads(resp['msg'])
            print("     Updater Name        Set Name")
            print("--------------------- ---------------- ")
            for updtr in updaters:
                print("{0:21}".format(updtr['name']))
                for set_ in updtr['match_sets']:
                    print("                     {0:16}".format(set_))

    def complete_updtr_match_list(self, text, line, begidx, endidx):
        return self.__complete_attr_list('updtr_match_list', text)

    def do_updtr_prdcr_add(self, arg):
        """
        Add matching Producers to an Updater policy. The parameters are as
        follows:
        name=   The update policy name
        regex=  A regular expression matching zero or more producers
        """
        self.handle('updtr_prdcr_add', arg)

    def complete_updtr_prdcr_add(self, text, line, begidx, endidx):
        return self.__complete_attr_list('updtr_prdcr_add', text)

    def do_updtr_prdcr_del(self, arg):
        """
        Remove matching Producers from an Updater policy. The parameters are as
        follows:
        name=    The update policy name
        regex=   A regular expression matching zero or more producers
        """
        self.handle('updtr_prdcr_del', arg)

    def complete_updtr_prdcr_del(self, text, line, begidx, endidx):
        return self.__complete_attr_list('updtr_prdcr_del', text)

    def do_updtr_start(self, arg):
        """
        Start updaters. The parameters to the commands are as
        follows:
        name=     The update policy name
        [interval=] The update interval in micro-seconds. If this is not
                  specified, the previously configured value will be used.
        [offset=]   Offset for synchronization
                    If 'interval' is given but not 'offset,
                    the updater will update sets asynchronously.
        [auto_interval=]   [true|false] If true, the updater will schedule
                           set updates according to the update hint. If false,
                           the updater will schedule the set updates according
                           to the default schedule, i.e., the given interval and offset values.
        """
        self.handle('updtr_start', arg)

    def complete_updtr_start(self, text, line, begidx, endidx):
        return self.__complete_attr_list('updtr_start', text)

    def do_updtr_stop(self, arg):
        """
        Stop the Updater. The Updater must be stopped in order to
        change it's configuration.
        Paramaeters:
        name=   The update policy name
        """
        self.handle('updtr_stop', arg)

    def complete_updtr_stop(self, text, line, begidx, endidx):
        return self.__complete_attr_list('updtr_stop', text)

    def do_strgp_add(self, arg):
        """
        Create a Storage Policy and open/create the storage instance.
        Parameters:
        name=      The unique storage policy name.
        plugin=    The name of the storage backend.
        container= The storage backend container name.
        schema=    The schema name of the metric set to store.
        [flush=]   The interval between calls to the storage plugin flush method.
                   By default, the flush method is not called.
        [perm=]    The permission to modify the storage policy in the future.
        [decomposition=]   Path to a decomposition configuration file
        """
        self.handle('strgp_add', arg)

    def complete_strgp_add(self, text, line, begidx, endidx):
        return self.__complete_attr_list('strgp_add', text)

    def do_strgp_del(self, arg):
        """
        Remove a Storage Policy. All updaters must be stopped in order for
        a storage policy to be deleted.
        Parameters:
        name=   The storage policy name
        """
        self.handle('strgp_del', arg)

    def complete_strgp_del(self, text, line, begidx, endidx):
        return self.__complete_attr_list('strgp_del', text)

    def do_strgp_prdcr_add(self, arg):
        """
        Add a regular expression used to identify the producers this
        storage policy will apply to.
        Parameters:
        name=   The storage policy name
        regex=  A regular expression matching metric set producers
        """
        self.handle('strgp_prdcr_add', arg)

    def complete_strgp_prdcr_add(self, text, line, begidx, endidx):
        return self.__complete_attr_list('strgp_prdcr_add', text)

    def do_strgp_prdcr_del(self, arg):
        """
        Remove a regular expression from the producer match list.
        Parameters:
        name=   The storage policy name
        regex=  The regular expression to remove
        """
        self.handle('strgp_prdcr_del', arg)

    def complete_strgp_prdcr_del(self, text, line, begidx, endidx):
        return self.__complete_attr_list('strgp_prdcr_del', text)

    def do_strgp_metric_add(self, arg):
        """
        Add the name of a metric to store. If the metric list is NULL,
        all metrics in the metric set will be stored.
        Parameters:
        name=   The storage policy name
        metric= The metric name
        """
        self.handle('strgp_metric_add', arg)

    def complete_strgp_metric_add(self, text, line, begidx, endidx):
        return self.__complete_attr_list('strgp_metric_add', text)

    def do_strgp_metric_del(self, arg):
        """
        Remove a metric from the set of stored metrics.
        Parameters:
        name=   The storage policy name
        metric= The metric to remove
        """
        self.handle('strgp_metric_del', arg)

    def complete_strgp_set_del(self, text, line, begidx, endidx):
        return self.__complete_attr_list('strgp_metric_del', text)

    def do_strgp_start(self, arg):
        """
        Start storage policy.
        name=    The storage policy name
        """
        self.handle('strgp_start', arg)

    def complete_strgp_start(self, text, line, begidx, endidx):
        return self.__complete_attr_list('strgp_start', text)

    def do_strgp_stop(self, arg):
        """
        Stop storage policies. A storage policy must be stopped in order to
        change its configuration.
        Paramaeters:
        name=    The storage policy name
        """
        self.handle('strgp_stop', arg)

    def complete_strgp_stop(self, text, line, begidx, endidx):
        return self.__complete_attr_list('strgp_stop', text)

    def do_daemon_status(self, arg):
        """
        Report the daemon status
        Parameters: NONE
        """
        resp = self.handle('daemon_status', arg)
        if resp['errcode'] == 0:
            o = json.loads(resp['msg'])
            print(f"Deamon State: {o['state']}\n")
            self.display_thread_stats(o['thread_stats'])

    def complete_daemon_status(self, text, line, begidx, endidx):
        return self.__complete_attr_list('daemon_status', text)

    def do_prdcr_status(self, arg):
        """
        Get the statuses of all producers
        Parameters:
        [name=]        producer name
        """
        resp = self.handle('prdcr_status', arg)
        if resp['errcode'] == 0:
            producers =  json.loads(resp['msg'])
            print("Name             Host             Port         Transport    State")
            print("---------------- ---------------- ------------ ------------ ------------")
            for prdcr in producers:
                print("{0:16} {1:16} {2:12} {3:12} {4:12}".format(prdcr['name'],
                                                                  prdcr['host'],
                                                                  prdcr['port'],
                                                                  prdcr['transport'],
                                                                  prdcr['state']))
                for pset in prdcr['sets']:
                    print("    {0:16} {1:16} {2}".format(pset['inst_name'],
                                                         pset['schema_name'],
                                                         pset['state']))

    def complete_prdcr_status(self, text, line, begidx, endidx):
        return self.__complete_attr_list('prdcr_status', text)

    def do_prdcr_set_status(self, arg):
        """
        Report the statuses of producer sets that are matched the given conditions.
        Parameters:
        [producer=]        Producer name
        [instance=]        Instance name
        [schema=]          Schema name
        """
        resp = self.handle('prdcr_set_status', arg)
        if resp['errcode'] == 0:
            from datetime import datetime
            metric_sets = json.loads(resp['msg'])

            print("Name                 Schema Name      State      Origin           Producer         timestamp                duration (sec)")
            print("-------------------- ---------------- ---------- ---------------- ---------------- ------------------------- ---------------")
            for pset in metric_sets:
                ts = float(pset['timestamp.sec'])
                ts_sec = datetime.fromtimestamp(ts).strftime('%m-%d-%y %H:%M:%S')
                ts_str = "{0} [{1}]".format(ts_sec, pset['timestamp.usec'])
                dur = pset['duration.sec'] + "." + pset['duration.usec'].zfill(6)
                print("{0:20} {1:16} {2:10} {3:16} {4:16} {5:25} {6:12}".format(pset['inst_name'],
                                                                                pset['schema_name'],
                                                                                pset['state'],
                                                                                pset['origin'],
                                                                                pset['producer'],
                                                                                ts_str,
                                                                                dur))

    def complete_prdcr_set_status(self, text, line, begidx, endidx):
        return self.__complete_attr_list('prdcr_set_status', text)

    def do_updtr_status(self, arg):
        """
        Get the statuses of all Updaters.

        Parameters:
        [name=]        updater name
        [Summary]     not show updaters' producers
        """
        resp = self.handle('updtr_status', arg)
        if resp['errcode'] == 0:
            updaters = json.loads(resp['msg'])
            print("Name             Interval:Offset  Auto   Mode            State        Skipped counter Oversampled counter")
            print(f"---------------- ---------------- ------ --------------- ------------ {'-'*15} {'-'*19}")
            for updtr in updaters:
                if 'auto' in updtr:
                    auto = updtr['auto']
                else:
                    # for backward compatabiliity
                    auto = updtr['????']
                interval_s = cvt_intrvl_off_to_str(updtr['interval'], updtr['offset'])
                print(f"{updtr['name']:16} {interval_s:16} {auto:6} {updtr['mode']:15} " \
                      f"{updtr['state']:10} {updtr['outstanding count']:15} " \
                      f"{updtr['oversampled count']:19}")
                if 'summary' not in arg:
                    for prdcr in updtr['producers']:
                        print("    {0:16} {1:16} {2:12} {3:12} {4:12}".format(
                            prdcr['name'], prdcr['host'], prdcr['port'],
                            prdcr['transport'], prdcr['state']))

    def complete_updtr_status(self, text, line, begidx, endidx):
        return self.__complete_attr_list('updtr_status', text)

    def __update_time_stats(self, updtr):
        stats = {'min' : float("inf"),
                 'max' : 0,
                 'avg' : 0,
                 'sum' : 0,
                 'cnt' : 0,
                 'min_prdcr' : None,
                 'max_prdcr' : None,
                 'producers' : {}
               }

        for p, prdcr in updtr.items():
            pstats = { 'min' : float("inf"),
                       'max' : 0,
                       'sum' : 0,
                       'avg' : 0,
                       'cnt' : 0,
                       'min_prdset' : None,
                       'max_prdset' : None,
                       'sets' : {}
                    }
            for s, prdset in prdcr.items():
                pstats['sets'][s] = {'min' : prdset['min'],
                                     'max' : prdset['max'],
                                     'avg' : prdset['avg'],
                                     'cnt' : prdset['cnt']
                                    }
                if pstats['min'] > prdset['min']:
                    pstats['min'] = prdset['min']
                    pstats['min_prdset'] = s
                if pstats['max'] < prdset['max']:
                    pstats['max'] = prdset['max']
                    pstats['max_prdset'] = s
                pstats['avg'] = pstats['avg'] * (pstats['cnt']/(pstats['cnt'] + prdset['cnt']))
                pstats['avg'] += prdset['avg'] * (prdset['cnt']/(pstats['cnt'] + prdset['cnt']))
                pstats['cnt'] += prdset['cnt']
            stats['producers'][p] = pstats

            if stats['min'] > pstats['min']:
                stats['min'] = pstats['min']
                stats['min_prdcr'] = p
            if stats['max'] < pstats['max']:
                stats['max'] = pstats['max']
                stats['max_prdcr'] = p
            stats['avg'] = stats['avg'] * (stats['cnt']/(stats['cnt'] + pstats['cnt']))
            stats['avg'] += pstats['avg'] * (pstats['cnt']/(stats['cnt'] + pstats['cnt']))
            stats['cnt'] += pstats['cnt']
        return stats

    def do_update_time_stats(self, arg):
        """
        Get the update time statistics of updaters

        Parameters:
        [name=]        updater name
        """
        resp = self.handle('update_time_stats', arg)
        if resp['errcode'] != 0:
            return

        j = json.loads(resp['msg'])
        print("Updater         Min(usec)       Max(usec)       Average(usec)   Count     ")
        print(f"{'-'*15} {'-'*15} {'-'*15} {'-'*15} {'-'*10}")
        for n, updtr in j.items():
            stats = self.__update_time_stats(updtr)
            print(f"{n:15} {stats['min']:15.4f} {stats['max']:15.4f} {stats['avg']:15.4f} {stats['cnt']:10}")

    def complete_update_time_stats(self, text, line, begidx, endidx):
        return self.__complete_attr_list('update_time_stats', text)

    def do_strgp_status(self, arg):
        """
        Get the status of storage policies
        Parameters:
            [name=]    a storage policy name
        """
        resp = self.handle('strgp_status', arg)
        if resp['errcode'] == 0:
            policies = json.loads(resp['msg'])
            print("Name             Container        Schema           Plugin           flush(sec)       State")
            print("---------------- ---------------- ---------------- ---------------- ------------ ----------------")
            for strgp in policies:
                print("{0:16} {1:16} {2:16} {3:16} {4:16} {5}".format(
                    strgp['name'], strgp['container'], strgp['schema'],
                    strgp['plugin'], strgp['flush'], strgp['state']))
                print("    producers: ", end='')
                for prdcr in strgp['producers']:
                    print("{0} ".format(prdcr), end='')
                print('')
                print("    metrics: ", end='')
                for metric in strgp['metrics']:
                    print("{0} ".format(metric), end='')
                print('')

    def complete_strgp_status(self, text, line, begidx, endidx):
        return self.__complete_attr_list('strgp_status', text)

    def do_store_time_stats(self, arg):
        """
        Get the store time statistics of a storage policy
        Parameters:
            [name=]    a storage policy name
        """
        resp = self.handle('store_time_stats', arg)
        if resp['errcode'] != 0:
            # self.handle() already reported the error.
            return
        j = json.loads(resp['msg'])
        print("strgp           min(usec)       max(usec)      avg(usec)      Count")
        print(f"{'-'*15} {'-'*15} {'-'*15} {'-'*15} {'-'*10}")
        for n, strgp in j.items():
            print(f"{n:15} {strgp['min']:15.4f} {strgp['max']:15.4f} {strgp['avg']:15.4f} {strgp['cnt']:10}")

    def complete_store_time_stats(self, text, line, begidx, endidx):
        return self.__complete_attr_list('store_time_stats', text)

    def do_plugn_status(self, arg):
        resp = self.handle('plugn_status', None)
        if resp:
            plugins = json.loads(resp['msg'])
            print("Name         Type         Interval     Offset       Libpath")
            print("------------ ------------ ------------ ------------ ------------")
            for plugn in plugins:
                print("{0:12} {1:12} {2:12} {3:12} {4:12}".format(
                    plugn['name'], plugn['type'],
                    plugn['sample_interval_us'], plugn['sample_offset_us'],
                    plugn['libpath']))

    def do_plugn_sets(self, arg):
        """
        List the sets by the plugin that provides the sets
        Parameters:
        [name=]   The plugin name
        """
        resp = self.handle('plugn_sets', arg)
        if resp is None:
            return
        if 0 != resp['errcode']:
            return
        plugns = json.loads(resp['msg'])
        for p in plugns:
            print("{0}:".format(p['plugin']))
            for s in p['sets']:
                print("   {0}".format(s))

    def do_publish(self, arg):
        """
        Publish data to the named stream
        Parameters:
        name=   The stream name
        data=   The data to publish
        """
        resp = self.handle('publish', arg)
        print(resp['errcode'])

    def do_subscribe(self, arg):
        """
        Subscribe to a stream.

        The aggregator will listen for published data on the specified stream.

        Parameters:
        name=   The stream name
        """
        resp = self.handle('subscribe', arg)
        print(resp['errcode'])

    def do_status(self, arg):
        """
        Report the statuses of producers, updaters and storage policies
        One or more of prdcr, updtr and strgp can be given to limit
        the status report only for the given types.
        Example:
            > status
        or
            > status prdcr updtr
        or
            > status prdcr name=sampler1
        """
        all__ = (len(arg) == 0)
        if "plugn" in arg or all__:
            self.do_plugn_status(arg)
        if "prdcr" in arg or all__:
            self.do_prdcr_status(arg)
        if "updtr" in arg or all__:
            self.do_updtr_status(arg)
        if "strgp" in arg or all__:
            self.do_strgp_status(arg)

    def do_term(self, arg):
        """
        Unload the plugin
        Parameters:
        name=   The plugin name
        """
        self.handle('term', arg)

    def complete_term(self, text, line, begidx, endidx):
        return self.__complete_attr_list('term', text)

    def do_config(self, arg):
        """
        Send a configuration command to the specified plugin.
        Parameters:
        name=   The plugin name
        ...     Plugin specific attr=value tuples
        """
        self.handle('config', arg)

    def complete_config(self, text, line, begidx, endidx):
        return self.__complete_attr_list('config', text)

    def do_start(self, arg):
        """
        Start a sampler plugin
        Parameters:
        name=     The plugin name
        interval= The sample interval in microseconds
        [offset=] Optional offset (shift) from the sample mark in microseconds.
                  Offset can be positive or negative with magnitude up to 1/2
                  the sample interval. If this offset is specified, including 0,
                  collection will be synchronous; if the offset is not specified,
                  collection will be asynchronous.
        """
        self.handle('start', arg)

    def complete_start(self, text, line, begidx, endidx):
        return self.__complete_attr_list('start', text)

    def do_stop(self, arg):
        """
        Stop a sampler plugin
        Parameters:
        name=     The plugin name
        """
        self.handle('stop', arg)

    def complete_stop(self, text, line, begidx, endidx):
        return self.__complete_attr_list('stop', text)

    def do_udata(self, arg):
        """
        Set the user data value for a metric in a metric set. This is typically used to
        convey the Component Id to the Aggregator.
        Parameters:
        instance=   The instance name
        metric= The metric name
        udata=  The desired user-data. This is a 64b unsigned integer.
        """
        self.handle('udata', arg)

    def complete_udata(self, text, line, begidx, endidx):
        return self.__complete_attr_list('udata', text)

    def do_udata_regex(self, arg):
        """
        Set the user data of multiple metrics using regular expression.
        The user data of the first matched metric is set to the base value.
        The base value is incremented by the given 'incr' value and then
        sets to the user data of the consecutive matched metric and so on.
        Parameters:
             instance=      The instance name
             regex=         A regular expression to match metric names to be set
             base=          The base value of user data (uint64)
             [incr=]        Increment value (int). The default is 0. If incr is 0,
                            the user data of all matched metrics are set
                            to the base value.
        """
        self.handle('udata_regex', arg)

    def complete_udata_regex(self, text, line, begidx, endidx):
        return self.__complete_attr_list('udata_regex', text)

    def do_loglevel(self, arg):
        """
        Changing the verbosity level of ldmsd
        Parameters:
        level=    Verbosity levels [DEBUG, INFO, ERROR, CRITICAL, QUIET]
        """
        self.handle('loglevel', arg)

    def complete_loglevel(self, text, line, begidx, endidx):
        return self.__complete_attr_list('loglevel', text)

    def do_logrotate(self, arg):
        """
        Close the current log file, rename it by appending
	the timestamp in seconds, and then open a new file
	with the name given at the ldmsd command-line.
        """
        self.handle('logrotate', arg)

    def complete_logrotate(self, text, line, begidx, endidx):
        return self.__complete_attr_list('logrotate', text)

    def do_version(self, arg):
        """
        Get the LDMS version the running LDMSD bases on.
        """
        resp = self.handle('version', arg)
        if 'errcode' in resp.keys() and resp['errcode'] == 0:
            print(resp['msg'])

    def do_include(self, arg):
        """
        Include a configuration file
        Parameters:
        path=    Path to the configuration file
        """
        self.handle('include', arg)

    def complete_include(self, text, line, begidx, endidx):
        return self.__complete_attr_list('include', text)

    def do_env(self, arg):
        """
        Set ldmsd environment
        """
        self.handle('env', arg)

    def do_EOF(self, arg):
        """
        Ctrl-D will exit the shell
        """
        return True

    def do_quit(self, arg):
        """
        Quit the LDMSD shell
        """
        if self.ctrl:
            self.ctrl.close()
        return True

    def do_oneshot(self, arg):
        """
        Make a sampler plugin to take a sample at a specific time
        Parameters:
        name=    Sampler plugin name
        time=    Timestamp since epoch. If 'now' is given, the sampler plugin will sample data right away.
        """
        self.handle('oneshot', arg)

    def complete_oneshot(self, text, line, begidx, endidx):
        return self.__complete_attr_list('oneshot', text)

    def do_greeting(self, arg):
        """
        Say hi to the ldmsd. If name="<string>" is given, ldmsd will echo the string back.
        If the parameter name is omitted, no responses will be returned.
        If a keyword 'test' is given, ldmsd will say 'Hi' back. E.g., greeting test.
        Parameter:
        [name=]   String that ldmsd will echo back.
        [offset=]  Number of characters in the response message.
        [level=]   Number of records in the response message.
        [test]    'Hi' will be returned.
        [path]    String 'XXX:YYY:...:ZZZ' will be returned, where 'XXX', 'YYY' and 'ZZZ'
                  are myhostname of the first producer in the list of each daemon.
        """
        resp = self.handle('greeting', arg)
        if "level" in arg:
            tbl = bytes(range(0, 256)) # identity mapping tbl
            for attr in resp['attr_list']:
                print(attr.attr_value.translate(tbl, delete=b' \x00').decode())
        elif resp['msg'] and resp['msg'] != "":
            print(resp['msg'])

    def complete_greeting(self, text, line, begidx, endidx):
        return self.__complete_attr_list('greeting', text)

    def do_example(self, arg):
        resp = self.handle('example', arg)
        if resp['msg'] == "":
            return

        attr_list = json.loads(resp['msg'])
        print("{0:10} {1:10} {2}".format("ATTR_ID", "VALUE_LENGTH", "VALUE"))
        print("---------- ---------- ----------")
        for attr in attr_list:
            print("{0:10} {1:10} {2}".format(attr['attr_id'], attr['attr_len'], attr['attr_value']))

    def do_failover_config(self, arg):
        """Configure LDMSD failover.

        Parameters:
            host=               The host name of the failover partner.
                                This is optional in re-configuration.
            xprt=               The transport of the failover partner.
                                This is optional in re-configuration.
            port=               The LDMS port of the failover partner.
                                This is optional in re-configuration.
            [auto_switch=0|1]   Auto switching (failover/failback).
            [interval=]         The interval of the heartbeat.
            [timeout_factor=]   The hearbeat timeout factor.
            [peer_name=]        The failover partner name. If not given,
                                the ldmsd will accept any partner.
        """
        self.handle('failover_config', arg)

    def complete_failover_config(self, text, line, begidx, endidx):
        return self.__complete_attr_list('failover_config', text)

    def do_failover_start(self, arg):
        """Start LDMSD failover service.

        NOTE: After the failover service has started, aggregator configuration
        objects (prdcr, updtr, and strgp) are not allowed to be altered (start,
        stop, or reconfigure).
        """
        self.handle('failover_start', arg)

    def complete_failover_start(self, text, line, begidx, endidx):
        return self.__complete_attr_list('failover_start', text)

    def do_failover_stop(self, arg):
        """Stop LDMSD failover service."""
        self.handle('failover_stop', arg)

    def complete_failover_stop(self, text, line, begidx, endidx):
        return self.__complete_attr_list('failover_stop', text)

    def do_failover_status(self, arg):
        """Get failover status."""
        resp = self.handle('failover_status', None)
        if resp['errcode'] != 0:
            print("Request returned error {0}".format(resp['errcode']))
            return

        fobj =  json.loads(resp['msg'])
        # print fobj['attr']
        print('Failover Status:')
        keys = fobj.keys()
        keys.remove('flags')
        for k in keys:
            print('    %s: %s' % (k, str(fobj[k])))
        print('    flags: ')
        for fl, v in fobj['flags'].items():
            print('        %s: %s' % (fl, str(v)))

    def complete_failover_mod(self, text, line, begidx, endidx):
        return self.__complete_attr_list('failover_mod', text)

    def do_failover_peercfg_start(self, arg):
        """Manually start peer configuration."""
        self.handle('failover_peercfg_start', arg)

    def do_failover_peercfg_stop(self, arg):
        """Manually stop peer configuration."""
        self.handle('failover_peercfg_stop', arg)

    def do_setgroup_add(self, arg):
        """Create a new setgroup.

        Parameters:
            name=           The set group name.
            [producer=]     The producer name of the set group.
            [interval=]     The update interval hint (in usec).
            [offset=]       The update offset hint (in usec).
            [perm=]         The permission to modify the setgroup in the future.
        """
        self.handle('setgroup_add', arg)

    def complete_setgroup_add(self, text, line, begidx, endidx):
        return self.__complete_attr_list('setgroup_add', text)

    def do_setgroup_mod(self, arg):
        """Modify attributes of a set group.

        Parameters:
            name=           The set group name.
            [interval=]     The update interval hint (in usec).
            [offset=]       The update offset hint (in usec).
        """
        self.handle('setgroup_mod', arg)

    def complete_setgroup_mod(self, text, line, begidx, endidx):
        return self.__complete_attr_list('setgroup_mod', text)

    def do_setgroup_del(self, arg):
        """Delete a set group

        Parameters:
            name=    The set group name to delete.
        """
        self.handle('setgroup_del', arg)

    def complete_setgroup_del(self, text, line, begidx, endidx):
        return self.__complete_attr_list('setgroup_del', text)

    def do_setgroup_ins(self, arg):
        """Insert sets into the set group

        Parameters:
            name=     The set group name.
            instance= The comma-separated list of set instances to add.
        """
        self.handle('setgroup_ins', arg)

    def complete_setgroup_ins(self, text, line, begidx, endidx):
        return self.__complete_attr_list('setgroup_ins', text)

    def do_setgroup_rm(self, arg):
        """Remove sets from the set group

        Parameters:
            name=     The set group name.
            instance= The comma-separated list of set instances to remove.
        """
        self.handle('setgroup_rm', arg)
        pass

    def complete_setgroup_rm(self, text, line, begidx, endidx):
        return self.__complete_attr_list('setgroup_rm', text)

    def complete_example(self, text, line, begidx, endidx):
        return self.__complete_attr_list('example', text)

    def __ts2human(self, sec, usec):
        from datetime import datetime
        ts = float(sec)
        ts_sec = datetime.fromtimestamp(ts).strftime('%m-%d-%y %H:%M:%S')
        ts_str = "{0} [{1}]".format(ts_sec, usec)
        return ts_str

    def do_set_route(self, arg):
        """
        Display the route of the set from aggregators to the sampler daemon.
        Parameters:
        instance=   Set instance name
        """
        resp = self.handle('set_route', arg)
        attr_list = resp['attr_list']
        if attr_list is None:
            print("No response back")

        if attr_list[0].attr_id != LDMSD_Req_Attr.JSON:
            # Assume that this is an error message
            return

        try:
            src = json.loads(attr_list[0].attr_value)
            route = src['route']
            print("---------------------")
            print("instance: '{0}'".format(src['instance']))
            print("schema: '{0}'".format(src['schema']))
            print("=====================")
            print("{0:20} {1:15} {2:15} {3:15} {4:10} {5:10} {6:5} {7:25} {8:25}".format(
                "host", "type", "name", "prdcr_host", "interval", "offset", "sync", "start", "end"))
            print("-------------------- --------------- --------------- --------------- "
                    "---------- ---------- ----- ------------------------- -------------------------")
            for hop in route:
                detail = hop['detail']
                if hop['type'] == "producer":
                    print("{0:20} {1:15} {2:15} {3:15} {4:10} {5:10} {6:5} {7:25} {8:25}".format(
                        hop['host'], hop['type'], detail['name'], detail['host'], detail['update_int'],
                        detail['update_off'], detail['update_sync'],
                        self.__ts2human(detail['last_start_sec'], detail['last_start_usec']),
                        self.__ts2human(detail['last_end_sec'], detail['last_end_usec'])))
                else:
                    print("{0:20} {1:15} {2:15} {3:15} {4:10} {5:10} {6:5} {7:25} {8:25}".format(
                        hop['host'], hop['type'], detail['name'], "---", detail['interval_us'],
                        detail['offset_us'], detail['sync'],
                        self.__ts2human(detail['trans_start_sec'], detail['trans_start_usec']),
                        self.__ts2human(detail['trans_end_sec'], detail['trans_end_usec'])))
        except:
            raise

    def complete_set_route(self, text, line, begidx, endidx):
        return self.__complete_attr_list('set_info', text)

    def display_thread_stats(self, stats):
        print(f"{'Name':16} {'Samples':12} {'Sample Rate':12} " \
              f"{'Utilization':12} {'Send Queue Size':16} " \
              f"{'Num of EPs':12}")
        print("---------------- ------------ ------------ ------------ "\
              "---------------- ------------")
        for e in stats['entries']:
            print(f"{e['name']:16} {e['sample_count']:12.0f} " \
                  f"{e['sample_rate']:12.2f} {e['utilization'] * 100:12.2f} " \
                  f"{e['sq_sz']:16} {e['n_eps']:12}")

    def do_thread_stats(self, arg):
        """
        Query the daemon's thread utilization statistics
        """
        resp = self.handle('thread_stats', arg)
        if resp['msg'] == "":
            return
        if resp['errcode'] != 0:
            return
        stats = json.loads(resp['msg'])
        self.display_thread_stats(stats)

    def complete_thread_stats(self, text, line, begidx, endidx):
        return self.__complete_attr_list('thread_stats', text)

    def display_prdcr_stats(self, stats):
        """
        {
            "prdcr_count" : <int>,
            "stopped" : <int>,
            "disconnected" : <int>,
            "connecting" : <int>,
            "connected" : <int>,
            "stopping"	: <int>,
            "compute_time" : <int>
        }
        """
        print(f"Producer Stats - {stats['compute_time']}us")
        print(f"{'Name':20} {'Count':16}")
        print("-------------------- ----------------")
        for n in stats:
            if n == 'compute_time':
                continue
            print(f"{n:20} {stats[n]:16}")

    def do_prdcr_stats(self, arg):
        """
        Query the daemon's producer statistics
        """
        resp = self.handle('prdcr_stats', arg)
        if resp['msg'] == "":
            return
        if resp['errcode'] != 0:
            return
        stats = json.loads(resp['msg'])
        self.display_prdcr_stats(stats)

    def complete_prdcr_stats(self, text, line, begidx, endidx):
        return self.__complete_attr_list('prdcr_stats', text)

    def display_set_stats(self, stats):
        """
        {
            "set_count" : <int>,
            "deleting_count" : <int>,
            "mem_total" : <int>,
            "mem_used" : <int>,
            "mem_free" : <int>,
            "compute_time" : <int>
        }
        """
        print(f"Set Stats - {stats['compute_time']}us")
        print(f"{'Name':20} {'Count':16}")
        print("-------------------- ----------------")
        for n in stats:
            if n == 'compute_time':
                continue
            print(f"{n:20} {stats[n]:16}")

    def do_set_stats(self, arg):
        """
        Query the daemon's set statistics
        """
        resp = self.handle('set_stats', arg)
        if resp['msg'] == "":
            return
        if resp['errcode'] != 0:
            return
        stats = json.loads(resp['msg'])
        self.display_set_stats(stats)

    def complete_set_stats(self, text, line, begidx, endidx):
        return self.__complete_attr_list('set_stats', text)

    def display_xprt_stats(self, stats):
        """
        { 'compute_time_us': 33,
          'connect_rate_s': 8e-06, 'connect_request_rate_s': 0.003638,
          'disconnect_rate_s': 0.003632, 'reject_rate_s': 0.0,
          'auth_fail_rate_s': 0.0, 'xprt_count': 32,
          'connect_count': 7, 'connecting_count': 0, 'listen_count': 1,
          'close_count': 24,
          'duration': 12353.23,
          'op_stats': {
            'LOOKUP': {'count': 3187, 'total_us': 162961103,
                        'min_us': 308, 'min_peer': '10.10.0.92:10001',
                        'min_peer_type': 'sock',
                        'max_us': 3290463, 'max_peer': '10.10.0.91:10001',
                        'max_peer_type': 'sock', 'mean_us': 51133},
            'UPDATE': {...},
            'PUBLISH': {...},
            'SET_DELETE': {...},
            'DIR_REQ': {...},
            'DIR_REP': {...},
            'SEND': {...},
            'RECV': {...}
          }
        }
        """
        heading = f"Summary over {stats['duration']:.2f} seconds"
        print(f"{heading:^64s}")
        print(f"{'Connected':12s} {'Connecting':12s} {'Listening':12s} {'Close':12s}")
        print("------------ ------------ ------------ ------------")
        print(f"{stats['connect_count']:12} {stats['connecting_count']:12} "
            f"{stats['listen_count']:12} {stats['close_count']:12}")
        print("")
        print(f"{'Rate/s':^64s}")
        print(f"{'Connect':12} {'Conn Req':12} {'Disconnect':12} {'Reject':12} {'Auth Fail':12}")
        print("------------ ------------ ------------ ------------ ------------")
        print(f"{stats['connect_rate_s']:12.2f} "
            f"{stats['connect_request_rate_s']:12.2f} "
            f"{stats['disconnect_rate_s']:12.2f} "
            f"{stats['reject_rate_s']:12.2f} "
            f"{stats['auth_fail_rate_s']:12.2f} "
            )
        print("")
        print(f"{'Operation':12} {'Count':12} {'Min(us)':12} {'Mean(us)':12} {'Max(us)':12} ")
        print("------------ ------------ ------------ ------------ ------------")
        op_stats = stats['op_stats']
        for op_name in op_stats:
            s = op_stats[op_name]
            print(f"{op_name:12} {s['count']:12} {s['min_us']:12} {s['mean_us']:12} {s['max_us']:12}")

    def do_xprt_stats(self, arg):
        """
        Query the daemon's transport telemetry data

        Parameters:
        [reset=]  If true, reset the statistics after returning them
        """
        resp = self.handle('xprt_stats', arg)
        if resp['msg'] == "":
            return
        if resp['errcode'] != 0:
            return
        stats = json.loads(resp['msg'])
        self.display_xprt_stats(stats)

    def complete_xprt_stats(self, text, line, begidx, endidx):
        return self.__complete_attr_list('xprt_stats', text)

    def do_updtr_task(self, arg):
        """
        Report the updater tasks
        Parameters:
        [name=]   Updater name
        """
        resp = self.handle('updtr_task', arg)
        if resp['msg'] == "":
            return
        if resp['errcode'] != 0:
            return
        updtrs = json.loads(resp['msg'])
        for updtr in updtrs:
            print("Updater : {0}".format(updtr['name']))
            print("   tasks: <interval_us>:<offset_us>")
            tasks = updtr['tasks']
            for task in tasks:
                if task['default_task'] == "true":
                    print("     {0}:{1}   default".format(task['interval_us'], task['offset_us']))
                else:
                    print("     {0}:{1}".format(task['interval_us'], task['offset_us']))

    def complete_updtr_task(self, text, line, begidx, endidx):
        return self.__complete_attr_list('updtr_task', text)

    def do_prdcr_hint_tree(self, arg):
        """
        Report the update hints of all producer sets
        Parameters:
        [name=]   Producer name
        """
        resp = self.handle('prdcr_hint_tree', arg)
        if resp['msg'] == "":
            return
        if resp['errcode'] != 0:
            return
        prdcrs = json.loads(resp['msg'])
        for prdcr in prdcrs:
            print("prdcr: {0}".format(prdcr['name']))
            hints = prdcr['hints']
            for hint in hints:
                print("   update hint: {0}:{1}".format(hint['interval_us'],
                                                       hint['offset_us']))
                sets = hint['sets']
                for s in sets:
                    print("      {0}".format(s))

    def complete_prdcr_hint_tree(self, text, line, begidx, endidx):
        return self.__complete_attr_list('prdcr_hint_tree', text)

    def do_stream_client_dump(self, arg):
        """
        Dump stream client information (for debugging)

        No parameters
        """
        resp = self.handle('stream_client_dump', None)
        if not resp:
            raise RuntimeError("no response")
        obj = json.loads(resp['msg'])
        print(json.dumps(obj, indent=2))

    def complete_stream_client_dump(self, text, line, begidx, endidx):
        return self.__complete_attr_list('stream_client_dump', text)

    def do_stream_dir(self, arg):
        """
        Dump the stream information

        No Parameters
        """
        FIRST = "first_ts"
        LAST = "last_ts"
        RATE = "bytes/sec"
        FREQ = "msg/sec"

        def dur(info):
            return (info[LAST] - info[FIRST])/60.0

        def rate(info):
            if not info or RATE not in info.keys():
                return "-"
            return info[RATE]

        def freq(info):
            if not info or FREQ not in info.keys():
                return "-"
            return info[FREQ]

        def total_bytes(info):
            if not info or "total_bytes" not in info.keys():
                return "-"
            return info["total_bytes"]

        def count(info):
            if not info or "count" not in info.keys():
                return "-"
            return info["count"]

        def first(info):
            if not info or "first_ts" not in info.keys():
                return "-"
            return info["first_ts"]

        def last(info):
            if not info or "last_ts" not in info.keys():
                return "-"
            return info["last_ts"]

        resp = self.handle('stream_dir', None)
        if resp is None:
            raise RuntimeError("no response")
        if (resp['errcode'] == 0):
            streams = json.loads(resp['msg'])
            print("name            mode            bytes/sec    msg/sec      total bytes  msg count    first msg    last msg    ")
            print("-" * 15, "-" * 15, "-" * 12, "-" * 12, "-" * 12, "-" * 12, "-" * 12, "-" * 12)
            # print("--------------- -------------- --------------- ----- ----------------- -----------\n")
            for name,s in streams.items():
                if name == "_AGGREGATED_":
                    s['mode'] = ""
                print(f"{name:15} {s['mode']:15} {rate(s['info']):>12} {freq(s['info']):>12} {total_bytes(s['info']):>12} {count(s['info']):>12} {first(s['info']):>12} {last(s['info']):>12}")
                if 'publishers' not in s.keys() or len(s['publishers']) == 0:
                    continue
                print("   Producers")
                for name,p in s['publishers'].items():
                    print(f"                {name:15} {rate(p['info']):>12} {freq(p['info']):>12} {total_bytes(p['info']):>12} {count(p['info']):>12} {first(p['info']):>12} {last(p['info']):>12}")

    def complete_stream_dir(self, text, line, begidx, endidx):
        return self.__complete_attr_list('stream_dir', text)

    def do_listen(self, arg):
        """
        Add a listen endpoint

        Parameters:
            xprt=   Transport name [sock, rdma, ugni]
            port=   Port number
            [host=] Hostname
            [auth=] Authenticantion domain.
                    If this is omitted or auth=auth_default is give,
                    the default authentication given the command line (-a and -A)
                    will be used..
        """
        self.handle('listen', arg)

    def complete_listen(self, text, lien, begidx, endidx):
        return self.__complete_attr_list('listen', text)

    def do_metric_sets_default_authz(self, arg):
        """
        Set the default authorization values for subsequently created metric sets

        Parameters:
            [uid=]  User ID number or user name string
            [gid=]  Group ID number or group name string
            [perm=] Octal number representing the permissions bits
        """
        self.handle('metric_sets_default_authz', arg)

    def complete_metric_sets_default_authz(self, text, line, begidx, endidx):
        return self.__complete_attr_list('metric_sets_default_authz', text)

    def do_auth_add(self, arg):
        """
        Add an authentication domain

        Parameters:
            name=      The authentication domain name
            [plugin=]  The authentication plugin [none, ovis, munge]
                       If this is omitted, the <name> value will be used as
                       a plugin name.
            <plugin-specific auth plugin attributes, path=.ldmsauth.conf>
        """
        self.handle('auth_add', arg)

    def complete_auth_add(self, text, line, begidx, endidx):
        return self.__complete_attr_list('auth_add', text)

    def do_option(self, arg):
        """
        ONLY SUPPORTED IN CONFIGURATION FILES
        Specify the command-line options

        Parameters:
            -A, -- defulat_auth_args    Arguments of the default authentication method
            -a, -- default_auth         Default authentication method
            -B, --banner                Banner mode: 0=do banner file, 1=auto-delete at exit, 2=keep the file
            -H, --host_name             Host/producer name used by the kernel metric sets
            -k, --publish_kernel        Publish kernel: true or false
            -l, --log_file              Path to the log file or 'syslog'
            -m, --set_memory            Set memory, e.g., 2GB, 512mB
            -n, --daemon_name           Daemon name
            -P, --worker_threads        Number of worker threads
            -r, --pid_file              Path to the PID file
            -s, --kernel_set_path       Path to a text file containing the kernel metric values
            -v, --log_level             Log level: DEBUG, INFO, ERROR, CRITICAL, QUIET

        Use 'listen' instead of the -x option.

        The following options must specified only at the command line.
            -c        Path to a configuration file
            -F        Foreground mode
            -u        List named plugins
            -V        Print LDMS version

        You would specify the command-line options as if you specify them at
        the command line.

        Examples:
           # Specify a short option
           option -a ovis
           # Specify multiple short options
           option -m 2GB -P 16
           # Specify multiple long options
           option --log_file /path/to/logfile --log_level ERROR
        """
        print("Not supported! The 'option' command is only supported in a configuration file.")

    def parseline(self, line):
        """Parse the line into a command name and a string containing
        the arguments.  Returns a tuple containing (command, args, line).
        'command' and 'args' may be None if the line couldn't be parsed.
        Allows # comments to begin lines, and dispatches these to do_comment
        when present.
        """
        line = line.strip()
        if not line:
            return None, None, line
        elif line[0] == '?':
            line = 'help ' + line[1:]
        elif line[0] == '!':
            if hasattr(self, 'do_shell'):
                line = 'shell ' + line[1:]
            else:
                return None, None, line
        elif line[0] == '#':
            if hasattr(self, 'do_comment'):
                line = 'comment ' + line[1:]
            else:
                return None, None, line
        i, n = 0, len(line)
        while i < n and line[i] in self.identchars: i = i+1
        cmd, arg = line[:i], line[i:].strip()
        return cmd, arg, line


if __name__ == "__main__":
    is_debug = True
    try:
        parser = argparse.ArgumentParser(description="Configure an LDMS Daemon. " \
                                         "To connect to an ldmsd, either give " \
                                         "the socket path of the ldmsd or " \
                                         "give both hostname and inet control port. " \
                                         "If all are given, the sockname takes the priority.",
                                         add_help=False)
        parser.add_argument('-?', '--help', action='help', default='==SUPPRESS==',
                help='show this help message and exit')
        parser.add_argument('-h','--host',
                            help = "Hostname of ldmsd to connect to",
                            default = 'localhost')
        parser.add_argument('-p','--port',
                            help = "Inet ctrl listener port of ldmsd")
        parser.add_argument('-x','--xprt',
                            help = "LDMS Transport type",
                            choices = ['sock', 'ugni', 'rdma', 'fabric'],
                            default = 'sock')
        parser.add_argument('--source',
                            help = "Path to the config file")
        parser.add_argument('--script',
                            help = "Execute the script and send the output \
                            commands to the connected ldmsd")
        parser.add_argument('--cmd',
                            help = "Command to be sent to an LDMSD")
        parser.add_argument('-a', '--auth',
                            help = "Authentication method.")
        parser.add_argument('-A', '--auth-arg', action = 'append',
                            help = "Authentication arguments (name=value). \
                                    This option can be given multiple times.")
        parser.add_argument('--debug', action = "store_true",
                            help = argparse.SUPPRESS)

        args = parser.parse_args()

        is_debug = args.debug

        auth_opt = None
        if args.auth_arg:
            auth_opt = dict()
            rx = re.compile(r"(\w+)=(.+)")
            for arg in args.auth_arg:
                m = rx.match(arg)
                if not m:
                    print("Expceting --auth-arg to be NAME=VALUE")
                    sys.exit(1)
                (k, v) = m.groups()
                auth_opt[k] = v

        cmdParser = LdmsdCmdParser(host = args.host,
                                   port = args.port,
                                   xprt = args.xprt,
                                   auth = args.auth,
                                   auth_opt = auth_opt)

        if args.source is not None or args.script is not None or args.cmd is not None:
            if args.source is not None:
                cmdParser.do_source(args.source)
            if args.script is not None:
                cmdParser.do_script(args.script)
            if args.cmd is not None:
                cmdParser.onecmd(args.cmd)
            cmdParser.do_quit(None)
        else:
            if sys.stdin.isatty() is False:
                cmdParser.read_none_tty(sys.stdin)
                cmdParser.do_quit(None)
            else:
                cmdParser.cmdloop("Welcome to the LDMSD control processor")
                cmdParser.do_quit(None)
    except KeyboardInterrupt:
        sys.exit(0)
    except Exception as e:
        if is_debug:
            raise
        else:
            print(e)
