%{
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include "ovis_json.h"

#define YYLTYPE struct json_loc_s
#define YYSTYPE json_entity_t

void yyerror(YYLTYPE *yylloc, json_parser_t parser, char *input, size_t input_len,
	     json_entity_t *pentity, const char *str)
{
	json_entity_free(*pentity);
}

#define YYDEBUG		1
#define YYERROR_VERBOSE 1

int yyparse(json_parser_t parser, char *input, size_t input_len, json_entity_t *entity);
void yy_delete_buffer(struct yy_buffer_state *);
int yylex(void *, YYLTYPE *loctype, json_parser_t, char *input, size_t input_len, yyscan_t scanner);
#define YYLEX_PARAM parser, input, input_len, parser->scanner
#define PARSER_SCANNER parser->scanner

static inline json_entity_t new_dict_val(void) {
	return json_entity_new(JSON_DICT_VALUE);
}

static inline json_entity_t add_dict_attr(json_entity_t e, json_entity_t name, json_entity_t value)
{
	if (json_attr_add(e, name->value.str_->str, value))
		return NULL;
	return e;
}

static inline json_entity_t new_list_val(void) {
	return json_entity_new(JSON_LIST_VALUE);
}

static inline json_entity_t add_list_item(json_entity_t e, json_entity_t v)
{
	json_item_add(e, v);
	return e;
}

%}

%define api.pure full
%locations

%lex-param { json_parser_t parser }
%lex-param { char *input }
%lex-param { size_t input_len }
%lex-param { yyscan_t PARSER_SCANNER }

%parse-param { json_parser_t parser }
%parse-param { char *input }
%parse-param { size_t input_len }
%parse-param { json_entity_t *pentity }

%token ',' ':'
%token '[' ']'
%token '{' '}'
%token '.'
%token '"'
%token DQUOTED_STRING_T SQUOTED_STRING_T
%token INTEGER_T FLOAT_T
%token BOOL_T
%token NULL_T

%start json

%%

json :  dict { *pentity = $$ = $1; YYACCEPT; }
	| array { *pentity = $$ = $1; YYACCEPT; }
	;

dict : '{' attr_list '}' { *pentity = $$ = $2; } ;

array : '[' item_list ']' { *pentity = $$ = $2; } ;

value : INTEGER_T { *pentity = $$ = $1; }
	 | FLOAT_T { *pentity = $$ = $1; }
	 | BOOL_T { *pentity = $$ = $1; }
	 | NULL_T { *pentity = $$ = $1; }
	 | string { *pentity = $$ = $1; }
	 | dict { *pentity = $$ = $1; }
	 | array { *pentity = $$ = $1; }
	 ;

string : DQUOTED_STRING_T { *pentity = $$ = $1; }
	 | SQUOTED_STRING_T { *pentity = $$ = $1; }
	 ;

attr_list: /* empty */ { *pentity = $$ = new_dict_val(); }
	 | string ':' value {
	     json_entity_t e = new_dict_val();
	     *pentity = $$ = add_dict_attr(e, $1, $3);
	     json_entity_free($1);
	 }
	 | attr_list ',' string ':' value {
	     *pentity = $$ = add_dict_attr($1, $3, $5);
	     json_entity_free($3);
	 }
     ;

item_list: /* empty */ { *pentity = $$ = new_list_val(); }
	| value {
		json_entity_t a = new_list_val();
		*pentity = $$ = add_list_item(a, $1);
	}
	| item_list ',' value {
		$$  = add_list_item($1, $3);
	}
    ;

%%

/* Implementation is in ovis_json_lexer.c, generated by ovis_json_lexer.l */
int yylex_init(yyscan_t *);

json_parser_t json_parser_new(size_t user_data)
{
	json_parser_t p = calloc(1, sizeof *p + user_data);
	if (p)
		yylex_init(&p->scanner);
	return p;
}

/* Implementation is in ovis_json_lexer.c, generated by ovis_json_lexer.l */
int yylex_destroy(yyscan_t);

void json_parser_free(json_parser_t parser)
{
	if (!parser)
		return;
	yylex_destroy(parser->scanner);
	free(parser);
}

